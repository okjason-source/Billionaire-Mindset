// Add this at the very top of script.js
console.log("Script loaded successfully");
let tradingBot = null;
let gameInterval = null;

// Add this with other global variables at the top
let bankroll = 1000000;
let totalSecondsRemaining = 30 * 86400; // 
let guns = 0;
let debt = 0;
let bankBalance = 0;
let loanBalance = 0;
let city = "New York";
let currentProduct = "weed";
let realTimeSeconds = 1000;
let transactionCount = 0; // Added to track actions for random events

// 1 real-life second = 1 game hour
//// Each in-game day lasts 24 real-time seconds - travel(6h=6s)
let botEnabled = false;
let botTrainingInterval = null;
                            
let inventory = {
    weed: 0,
    cocaine: 0,
    meth: 0,
    codeine: 0,
    lsd: 0,
    shrooms: 0,
};

const products = {
    weed: { 
        name: "Weed", 
        minPrice: 1600, 
        maxPrice: 10000,
        basePrice: 3000,
        currentPrice: 1600,
        volatility: 0.15,
        trend: 'up'
    },
    cocaine: { name: "Cocaine", minPrice: 2800, maxPrice: 25000 },
    meth: { name: "Meth", minPrice: 4500, maxPrice: 50000 },
    codeine: { name: "Codeine", minPrice: 140, maxPrice: 2000 },
    lsd: { name: "LSD", minPrice: 6100, maxPrice: 100000 },
    shrooms: { name: "Shrooms", minPrice: 550, maxPrice: 7500 }
};

// Add this near the top of your script, with other global variables at the top
const dayMessages = [
    "Plenty of time to stack it up high. We are going international. Let's get started.",
    "The bigger the risk, the bigger the reward.",
    "We're just warming up.",
    "The clock's ticking, but so is my bankroll.",
    "Time to turn up the heat.",
    "Halfway there. Time to double down.",
    "The money's moving, and so am I.",
    "It's go big or go home.",
    "No time for second thoughts.",
    "Last days to make it count. All or nothing."
];


// Initialize player data
const player = {
    bankroll: 1000000.00, // Starting bankroll
    holdings: {},      // Player's product holdings
    
};

// Add this variable at the top with other game state
let highLowPriceHistory = new Map(); // Tracks high/low prices per product

// Add global action tracker
let hasPerformedFirstAction = false;

// Initialize at the top of your script
let dayMessageIndex = 0;
const DAY_MESSAGES = [
    "Plenty of time to stack it up high. We are going international. Let's get started.",
    "The bigger the risk, the bigger the reward.",
    "We're just warming up.",
    "The clock's ticking, but so is my bankroll.",
    "Time to turn up the heat.",
    "Halfway there. Time to double down.",
    "The money's moving, and so am I.",
    "It's go big or go home.",
    "No time for second thoughts.",
    "Last days to make it count. All or nothing."
];

// At the top of the file, after any existing variable declarations
// Global variables
let gameState = {
    day: 1,
    cash: 1000000,
    bank: 0,
    loan: 0,
    inventory: {},
    currentCity: null,
    gameActive: true,
    totalDays: 30,
    bankInterest: 0.05,
    loanInterest: 0.1,
    gun: 0,
    health: 100,
    reputation: 50
};

// Add the missing bot control variables
let tradingBot = null;
let botEnabled = false;  // Start with bot disabled

// Function to get a random price between min and max for the selected product
function getRandomPrice(product, bankroll) {
    const minPrice = products[product].minPrice;
    const maxPrice = products[product].maxPrice;
    let randomPrice = Math.floor(Math.random() * (maxPrice - minPrice + 1)) + minPrice;
    
    // Ensure player can afford at least one unit
    if (randomPrice > bankroll) {
        randomPrice = Math.max(minPrice, bankroll);
    }

    // Store price in memory
    if(tradingBot) {
        tradingBot.recordPriceMovement(product, randomPrice);
    }
    
    return randomPrice;
}

// Function to save game state to localStorage
function saveGameState() {
    const gameState = {
        bankroll: bankroll,
        totalSecondsRemaining: totalSecondsRemaining,
        guns: guns,
        bankBalance: bankBalance,
        loanBalance: loanBalance,
        city: city,
        inventory: inventory,
        transactionCount: transactionCount, // Save transaction count
        botState: tradingBot ? tradingBot.saveState() : true,
        botEnabled: true, 
        botTrainingInterval: botTrainingInterval ? true : false
    };

    localStorage.setItem('gameState', JSON.stringify(gameState));
    console.log('Bot state saved:', tradingBot?.saveState());
}


// Function to update the buy and sell prices for the current product
function updatePrices() {
    const buyPrice = getRandomPrice(currentProduct, bankroll);

    // Calculate sell price range
    const sellPriceMin = Math.floor(buyPrice * 0.85);
    const sellPriceMax = Math.floor(buyPrice * 2.30);

    document.getElementById('buy-price').innerText = buyPrice.toLocaleString();
    document.getElementById('sell-price-range').innerText = sellPriceMin.toLocaleString();
    document.getElementById('sell-price-max').innerText = sellPriceMax.toLocaleString();
}

// Update initProductDropdown with null check
function initProductDropdown() {
    const dropdown = document.getElementById('product-dropdown');
    
    if (!dropdown) {
        // Recreate the dropdown if missing
        const newDropdown = document.createElement('select');
        newDropdown.id = 'product-dropdown';
        document.getElementById('actions').appendChild(newDropdown);
        return initProductDropdown(); // Retry initialization
    }

    // Clear existing options
    dropdown.innerHTML = '';
    
    for (let product in products) {
        const option = document.createElement('option');
        option.value = product;
        option.textContent = products[product].name;
        dropdown.appendChild(option);
    }

    // Update prices when product changes
    dropdown.addEventListener('change', (event) => {
        currentProduct = event.target.value;
        updatePrices();
    });

    // Prevent default behavior of arrow keys in dropdown
    dropdown.addEventListener('keydown', (event) => {
        if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
            event.preventDefault();
        }
    });

    // Set initial prices for the default product
    updatePrices();
}

// Update the logEvent function with null checks
function logEvent(message, type = 'general', additionalMessage = '') {
    const eventDisplay = document.getElementById('event-display');
    if (!eventDisplay) {
        console.log(message); // Fallback to console
        return;
    }
    
    if (type === 'buy' || type === 'sell') {
        eventDisplay.innerHTML = `${message}<br>${additionalMessage}`;
    } else {
        eventDisplay.textContent = message;
    }
}

// Update the UI
function updateUI() {
    console.log('[UI UPDATE]', {
        bankroll: bankroll,
        city: city,
        inventory: inventory,
        totalSecondsRemaining,
        formatted: formatTime(totalSecondsRemaining)
    });
    
    try {
        const elementsToUpdate = {
            'bankroll': bankroll,
            'days': formatTime(totalSecondsRemaining),
            'guns': guns,
            'city': city,
            'bank-balance': bankBalance,
            'loan-balance': loanBalance
        };
    
        // Update text elements
        Object.entries(elementsToUpdate).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                if (typeof value === 'number') {
                    element.innerText = value.toLocaleString();
                } else {
                    element.innerText = value;
                }
            }
        });
    
        // Update the inventory display
        updateInventory();
        
        // Update strategy display for the bot - only if controls exist
        if (tradingBot && botEnabled && document.getElementById('bot-controls')) {
            updateStrategyDisplay();
        }
        
        // Update statistics window if it exists
        if (typeof updateStatsWindow === 'function') {
            updateStatsWindow();
        }
        
        // Update gun display
        if (typeof updateGunDisplay === 'function') {
            updateGunDisplay();
        }
    } catch (error) {
        console.error('[UI UPDATE ERROR]', error);
    }
}


// Update inventory display
function updateInventory() {
    const inventoryElement = document.getElementById('inventory');
    if (!inventoryElement) return;
    
    // Clear previous inventory display
    inventoryElement.innerHTML = '';
    
    // Debug what inventory we're working with
    console.log("[INVENTORY UPDATE] Current gameState.inventory:", JSON.stringify(gameState.inventory));
    
    let totalInventoryValue = 0;
    
    // Make sure gameState.inventory exists
    if (!gameState.inventory) {
        gameState.inventory = {};
        console.log("[INVENTORY WARNING] Initialized empty gameState.inventory");
    }
    
    // Check if inventory is empty
    if (Object.keys(gameState.inventory).length === 0) {
        inventoryElement.innerHTML = '<div>No items in inventory</div>';
        return;
    }
    
    // Create inventory display
    for (const [productKey, quantity] of Object.entries(gameState.inventory)) {
        if (quantity <= 0 || !products[productKey]) continue;
        
        // Get product details
        const product = products[productKey];
        
        // Get current price or calculate an average if not available
        let currentPrice = 0;
        if (product.currentPrice) {
            currentPrice = product.currentPrice;
        } else if (product.minPrice && product.maxPrice) {
            currentPrice = Math.floor((product.minPrice + product.maxPrice) / 2);
        }
        
        // Calculate item value
        const itemValue = quantity * currentPrice;
        totalInventoryValue += itemValue;
        
        // Create inventory item element
        const itemElement = document.createElement('div');
        itemElement.innerHTML = `
            <span>${product.name}: ${quantity}</span>
            <span>Est. Value: $${itemValue.toLocaleString()}</span>
        `;
        inventoryElement.appendChild(itemElement);
    }
    
    // Add total value display
    const totalElement = document.createElement('div');
    totalElement.innerHTML = `<strong>Total Inventory Value: $${totalInventoryValue.toLocaleString()}</strong>`;
    totalElement.style.marginTop = '10px';
    inventoryElement.appendChild(totalElement);
    
    console.log(`[INVENTORY] Updated display with total value: $${totalInventoryValue.toLocaleString()}`);
}

// Update the cities array
const cities = ["New York", "London", "Tokyo", "Paris", "Sydney", "Bangkok", "Beijing", "Los Angeles", "Prague", "Berlin", "Bogota", "Mexico City", "Mumbai", "Rio de Janeiro", "Cairo", "Moscow", "Amsterdam"];

// Add this function to determine if a price is exceptionally low or high
function isExceptionalPrice(buyPrice, sellPrice) {
    const minPrice = products[currentProduct].minPrice;
    const maxPrice = products[currentProduct].maxPrice;
    const priceRange = maxPrice - minPrice;
    
    const isVeryLowBuy = buyPrice <= minPrice + (priceRange * 0.1);
    const isVeryHighProfit = sellPrice >= buyPrice * 5;
    
    return isVeryLowBuy || isVeryHighProfit;
}

// Update the travel time constant
const secondsPerTravel = 6 * 3600; // 6 hours in seconds

// Update the main travel function
function travel() {
        // Generate random city that's different from current one
        const cities = ["New York", "London", "Tokyo", "Paris", "Sydney", "Bangkok", "Beijing", "Los Angeles", "Prague", "Berlin", "Bogota", "Mexico City", "Mumbai", "Rio de Janeiro", "Cairo", "Moscow", "Amsterdam"];
        const availableCities = cities.filter(c => c !== city);
        const newCity = availableCities[Math.floor(Math.random() * availableCities.length)];
        
    // Update location and log basic travel info
        const oldCity = city;
        city = newCity;
        logEvent(`You traveled from ${oldCity} to ${city}`, "travel");
    
    // Add one of the engaging travel messages about the new city
    const travelMessages = [
        `${city} is where the action is tonight.`,
        `The streets of ${city} have a way of telling stories.`,
        `${city} is a town that never sleeps and neither do I.`,
        `In ${city}, the deals are always sweeter.`,
        `${city} calls to those who hear her ringing.`,
        `${city}... smells like opportunity.`,
        `Off to ${city}. Let's see what the weather brings.`,
        `${city}, where fortunes are made or lost.`,
        `${city}, time to get busy.`
    ];
    
    // Display a random travel message
    logEvent(travelMessages[Math.floor(Math.random() * travelMessages.length)], "travel");
    
    // Show travel ASCII art
    showAsciiArt('travel');
        
        // Update prices for the new city
        updatePrices();
        updateUI();
}


// Handle random events (police raids or robbers)
function randomEvent() {
    const eventChance = Math.random();
    const baseChance = 0.10; // Lower chance for bot
    
    if (eventChance < baseChance) { 
        policeRaid();
    } else if (eventChance < baseChance + 0.15) { 
        robbers();
    }
}

// Updated police raid messages
function policeRaid() {
    // Removed inventory confiscation
    const penalty = Math.min(bankroll * 0.15, 50000);
    bankroll = Math.max(0, bankroll - penalty);
    logEvent(`POLICE FINE! Paid $${penalty.toLocaleString()}`, 'alert');
}

// Updated robber messages
function robbers() {
    const stolenCash = Math.min(bankroll * 0.25, 100000);
    bankroll -= stolenCash;
    logEvent(`ROBBERY! Lost $${stolenCash.toLocaleString()}`, 'alert');
}

// Buying and Selling logic
function buyProduct() {
    try {
        const quantity = parseInt(document.getElementById('quantity').value || '0');
        const buyPrice = parseInt(document.getElementById('buy-price').textContent.replace(/,/g, '') || '0');
        const selectElement = document.getElementById('product-dropdown');
        
        if (!selectElement) {
            logEvent("Product selection unavailable");
            return false;
        }
        
        const currentProduct = selectElement.value;

        if (isNaN(quantity) || quantity <= 0) {
            logEvent("Invalid quantity");
            return false;
        }

        if (isNaN(buyPrice) || buyPrice <= 0) {
            logEvent("Invalid price");
            return false;
        }
        
        // Calculate total cost
        const totalCost = quantity * buyPrice;
        
        // Check if player has enough money
        if (totalCost > gameState.cash) {
            logEvent("Insufficient funds");
            return false;
        }

        // Log inventory before purchase for debugging
        console.log("[BUY DEBUG] Inventory before purchase:", JSON.stringify(gameState.inventory));
        
        // Update bankroll and inventory with proper rounding
        gameState.cash = Math.round((gameState.cash - totalCost) * 100) / 100; // Round to 2 decimal places
        
        // Ensure gameState.inventory is initialized
        if (!gameState.inventory) {
            gameState.inventory = {};
        }
        
        // Update gameState.inventory
        gameState.inventory[currentProduct] = (gameState.inventory[currentProduct] || 0) + quantity;
        
        // Log the transaction
        const logMessage = `Bought ${quantity} ${products[currentProduct].name} for $${totalCost.toLocaleString()}`;
        const additionalMessage = `You now have ${gameState.inventory[currentProduct]} ${products[currentProduct].name}`;
        logEvent(logMessage, 'buy', additionalMessage);
        
        // Log inventory after purchase for debugging
        console.log("[BUY DEBUG] Inventory after purchase:", JSON.stringify(gameState.inventory));
        
        // Update UI immediately
        updateUI();
        
        // Check for random events
        if (Math.random() < 0.25) randomEvent();
        
        // Debug log the bankroll change
        console.log(`[BANKROLL] After buy: $${gameState.cash.toLocaleString()} (-$${totalCost.toLocaleString()})`);
        
        return true;
    } catch (error) {
        console.error("[BUY ERROR]", error);
        logEvent("Error processing purchase");
        return false;
    }
}




function sellProduct() {
    try {
        // Get essential elements
        const quantityInput = document.getElementById('quantity');
        const selectElement = document.getElementById('product-dropdown');
        const sellPriceElement = document.getElementById('sell-price');
        
        if (!quantityInput || !selectElement) {
            console.error("[SELL ERROR] Required form elements not found");
            logEvent("Error processing sale - form not ready");
            return false;
        }
        
        // Get current values
        const quantity = parseInt(quantityInput.value || '0');
        const currentProduct = selectElement.value;
        
        // Validate product selection
        if (!currentProduct || !products[currentProduct]) {
            console.error("[SELL ERROR] Invalid product selection:", currentProduct);
            logEvent("Error processing sale - invalid product");
            return false;
        }
        
        // Check inventory
        if (!gameState.inventory[currentProduct] || gameState.inventory[currentProduct] < quantity) {
            logEvent(`Not enough ${products[currentProduct].name} in inventory`);
            return false;
        }
        
        // Validate quantity
        if (isNaN(quantity) || quantity <= 0) {
            logEvent("Invalid quantity");
            return false;
        }

        // Determine sell price - try multiple methods
        let sellPrice = 0;
        
        // Method 1: Get from DOM element
        if (sellPriceElement && sellPriceElement.textContent) {
            const priceText = sellPriceElement.textContent.replace(/[^0-9]/g, '');
            sellPrice = parseInt(priceText);
            console.log(`[SELL] Using UI price: $${sellPrice}`);
        } 
        
        // Method 2: Use product's currentPrice or calculate from min/max
        if (!sellPrice || isNaN(sellPrice) || sellPrice <= 0) {
            console.log("[SELL] UI price unavailable, using calculated price");
            
            if (products[currentProduct].currentPrice) {
                sellPrice = products[currentProduct].currentPrice;
            } else if (products[currentProduct].minPrice && products[currentProduct].maxPrice) {
                sellPrice = Math.floor((products[currentProduct].minPrice + products[currentProduct].maxPrice) / 2);
            } else {
                // Last resort fallback
                sellPrice = 100;
            }
            console.log(`[SELL] Calculated price: $${sellPrice}`);
        }
        
        // Final validation of price
        if (!sellPrice || isNaN(sellPrice) || sellPrice <= 0) {
            console.error("[SELL ERROR] Cannot determine a valid sell price");
            logEvent("Error processing sale - price calculation failed");
            return false;
        }

        // Calculate total revenue
        const totalRevenue = quantity * sellPrice;
        
        // Store old values for verification
        const oldCash = gameState.cash;
        const oldInventory = gameState.inventory[currentProduct];
        
        // Update game state
        gameState.inventory[currentProduct] -= quantity;
        if (gameState.inventory[currentProduct] <= 0) {
            delete gameState.inventory[currentProduct]; // Clean up empty inventory
        }
        gameState.cash = Math.round((gameState.cash + totalRevenue) * 100) / 100; // Round to avoid floating point issues
        
        // Verify the update succeeded
        if (gameState.cash <= oldCash) {
            console.error(`[SELL WARNING] Cash did not increase! Old: $${oldCash}, New: $${gameState.cash}`);
        }
        
        if (oldInventory - gameState.inventory[currentProduct] !== quantity) {
            console.error(`[SELL WARNING] Inventory reduction mismatch! Expected: ${oldInventory-quantity}, Got: ${gameState.inventory[currentProduct] || 0}`);
        }
        
        // Log the transaction
        const logMessage = `Sold ${quantity} ${products[currentProduct].name} for $${totalRevenue.toLocaleString()}`;
        const additionalMessage = gameState.inventory[currentProduct] > 0 
            ? `You have ${gameState.inventory[currentProduct]} ${products[currentProduct].name} left` 
            : `You're now out of ${products[currentProduct].name}`;
        
        logEvent(logMessage, 'sell', additionalMessage);
        
        // Debug log the transaction and bankroll update
        console.log(`[SELL] ${quantity} ${products[currentProduct].name} at $${sellPrice} each = $${totalRevenue.toLocaleString()}`);
        console.log(`[BANKROLL] After sell: $${gameState.cash.toLocaleString()} (+$${totalRevenue.toLocaleString()})`);
        
        // Update UI
        updateUI();
        updateInventory();
        
        // Check for random events (25% chance)
        if (Math.random() < 0.25) randomEvent();
        
        return true;
    } catch (error) {
        console.error("[SELL ERROR]", error);
        logEvent("Error processing sale");
        return false;
    }
}

function switchPage(page) {
    document.getElementById('game-container').classList.toggle('hidden', page !== 'game');
    document.getElementById('bank-page').classList.toggle('hidden', page !== 'bank');
    document.getElementById('loan-page').classList.toggle('hidden', page !== 'loan');

}

// Function to deposit money into the bank
function deposit(amount) {
    if (bankroll >= amount && amount > 0) {
        bankroll -= amount;
        bankBalance += amount;
        
        const depositMessages = [
            `$${amount.toLocaleString()} taken out of circulation, but the cycle continues.`,
            `$${amount.toLocaleString()} deposited, but the pipeline's still full.`,
            "The bank may have my money, but I've got my eyes on the next score."
        ];

        logEvent(depositMessages[Math.floor(Math.random() * depositMessages.length)]);
        
        updateUI();
    } else {
        logEvent("Not enough bankroll to deposit this amount or invalid input.");
    }
    hasPerformedFirstAction = true;
    handlePlayerAction();
}

// Function to withdraw money from the bank
function withdraw(amount) {
    if (bankBalance >= amount && amount > 0) {
        bankBalance -= amount;
        bankroll += amount;
        
        const withdrawMessages = [
            "Taking what's mine, leaving some behind.",
            "A withdrawal here, an investment there ‚Äì that's how it's played."
        ];

        logEvent(withdrawMessages[Math.floor(Math.random() * withdrawMessages.length)]);
        
        updateUI();
    } else {
        logEvent("Not enough bank balance to withdraw this amount or invalid input.");
    }
    hasPerformedFirstAction = true;
    handlePlayerAction();
}

// Function to take a loan
function takeLoan(amount, silent = false) {
    // Add a safety check for gameState
    if (typeof gameState === 'undefined') {
        console.error("[LOAN ERROR] Game state is not defined");
        return false;
    }
    
    if (isNaN(amount) || amount <= 0) {
        if (!silent) logEvent("Invalid loan amount");
        return false;
    }

    // Cap loans at 5,000,000
    if (gameState.loan + amount > 5000000) {
        if (!silent) logEvent("Loan limit reached!", "danger", "Maximum loan balance is $5,000,000");
        return false;
    }
    
    // Random loan messages
    const loanMessages = [
        "That's my ticket out.",
        "I've got an IOU, but I'm rich today.",
        "This loan is just a down payment on my future."
    ];
    
    // Add loan amount to game state
    gameState.loan += amount;
    gameState.cash += amount;
    
    if (!silent) {
        // Select a random message to display
        const randomMessage = loanMessages[Math.floor(Math.random() * loanMessages.length)];
        
        // Log the loan event with the thematic message
        logEvent(`Took a loan of $${amount.toLocaleString()}`, "info", randomMessage);
    }
    
    // Update UI
    updateUI();
    
    // Debug log
    console.log(`[BANKROLL] After loan: $${gameState.cash.toLocaleString()} (+$${amount.toLocaleString()})`);
    console.log(`[LOAN] New balance: $${gameState.loan.toLocaleString()}`);
  
    return true;
}

// Function to pay off a loan
function payLoan(amount) {
    if (bankroll >= amount && amount > 0) {
        loanBalance -= amount;
        bankroll -= amount;
        
        const payLoanMessages = [
            "Now I can collect what's owed to me.",
            "Almost even."
        ];

        logEvent(payLoanMessages[Math.floor(Math.random() * payLoanMessages.length)]);
        
        updateUI();
    } else {
        logEvent("Not enough bankroll to pay back this amount or invalid input.");
    }
    hasPerformedFirstAction = true;
    handlePlayerAction();
}

// Function to buy a gun (limit to 2 guns)
function buyGun() {
    if (guns >= 2) {
        logEvent("Maximum 2 guns allowed");
        return;
    }
    if (bankroll >= 250) {
        bankroll -= 250;
        guns += 1;
        
        const buyGunMessages = [
            "Some deals are just worth protecting.",
            "This is just a little insurance policy I like to carry with me.",
            "Just in case negotiations get spicy.",
            "For when conversations need a more... persuasive tone.",
            "This? Just a tool of the trade."
        ];

        logEvent(buyGunMessages[Math.floor(Math.random() * buyGunMessages.length)]);
        
        updateUI();
        updateGunDisplay();
    } else {
        logEvent("Not enough bankroll to buy a gun.");
    }
    hasPerformedFirstAction = true;
}

function updateGunDisplay() {
    const gunDisplay = document.getElementById('gun-counter');
    if (gunDisplay) {
        gunDisplay.textContent = `Guns: ${guns}/2`;
    }
}

// day tracking
const secondsPerDay = 1; // Each in-game day lasts 1 real-time second
const daysPerMessage = 3;

// Update these variables
const gameLength = 30 * 86400; // 30 days in seconds
const timeMultiplier = 1; // 1 game second per real second

// Initialize gameOverHandler at the top level
const gameOverHandler = {
    shown: false,
    
    show() {
        if (this.shown) return;
        DOM.get('game-container').classList.add('hidden');
        DOM.get('game-over').classList.remove('hidden');
        this.shown = true;
    },
    
    reset() {
        this.shown = false;
    }
};

// Add to game loop (same for both modes)
function trackDays() {
    if(gameInterval) clearInterval(gameInterval);
    
    gameInterval = setInterval(() => {
        // Decrement time only if game is active
        if(totalSecondsRemaining > 0) {
            totalSecondsRemaining = Math.max(0, totalSecondsRemaining - 3600);
            
            // Check if game has ended
            if(totalSecondsRemaining === 0) {
                console.log("Game time has ended!");
                showGameOver();
                return;
            }
        }
        
        // Log first message immediately on game start
        if(dayMessageIndex === 0) {
            logEvent(DAY_MESSAGES[0], 'update');
            dayMessageIndex = 1;
        }
        
        // Subsequent messages every 3 game days (72 real-world seconds)
        if(totalSecondsRemaining % (3 * 86400) === 0 && dayMessageIndex < DAY_MESSAGES.length) {
            logEvent(DAY_MESSAGES[dayMessageIndex], 'update');
            dayMessageIndex = (dayMessageIndex + 1) % DAY_MESSAGES.length;
        }
        
        // ... rest of trackDays logic ...
    }, 1000);
}

// Accrue daily bank interest and loan interest
function accrueInterest() {
    bankBalance += bankBalance * 0.04/12/30; // 4% daily APY
    loanBalance += loanBalance * 0.07/12/30; // 7% loan interest daily
    updateUI();
}

// Function to load game state from localStorage
function loadGameState() {
    const savedGameState = localStorage.getItem('gameState');
    
    if (savedGameState) {
        const gameState = JSON.parse(savedGameState);
        
        // Restore bot state with validation
        if (gameState.botState) {
            tradingBot = new TradingBot({
                qTable: gameState.botState.qTable || {},
                highLowPriceMemory: gameState.botState.highLowPriceMemory || [],
                epsilon: gameState.botState.epsilon || 0.9,
                cumulativeReward: gameState.botState.cumulativeReward || 0,
                totalSessions: gameState.botState.totalSessions || 0,
                strategyUsage: gameState.botState.strategyUsage || {},
                productRotationThreshold: gameState.botState.productRotationThreshold || 5,
                currentProductTrades: gameState.botState.currentProductTrades || 0
            });
            
            botEnabled = gameState.botEnabled || true;
        }
        
        // Restore game state
        bankroll = gameState.bankroll || 1000000;
        totalSecondsRemaining = gameState.totalSecondsRemaining || 30*86400;
        guns = gameState.guns || 0;
        bankBalance = gameState.bankBalance || 0;
        loanBalance = gameState.loanBalance || 0;
        city = gameState.city || "New York";
        inventory = gameState.inventory || Object.keys(products).reduce((acc, p) => {
            acc[p] = 0;
            return acc;
        }, {});
        transactionCount = gameState.transactionCount || 0; // Load transaction count

        updateUI();
        
        // Start the continuous timer display for the loaded game
        startGameTimerDisplay();
    }
}

function hideGameOver() {
    const gameOverElement = document.getElementById('game-over');
    if (gameOverElement) {
        gameOverElement.style.display = 'none';
    }
    
    // Clear the game timer interval when game is over
    if (window.gameTimerInterval) {
        clearInterval(window.gameTimerInterval);
        window.gameTimerInterval = null;
    }
}

function startNewGame() {
    // Reset game state
    gameState = {
        day: 1,
        cash: 1000000, // Explicitly set starting cash to 1,000,000
        bank: 0,
        loan: 0,
        inventory: {},
        currentCity: cities[Math.floor(Math.random() * cities.length)],
        gameActive: true,
        totalDays: 30,
        bankInterest: 0.05,
        loanInterest: 0.1,
        gun: 0,
        health: 100,
        reputation: 50
    };

    // Initialize product prices
    updatePrices();

    // Clear inventory
    document.getElementById('inventory').innerHTML = '';
    updateInventory();

    // Update UI
    updateUI();

    // Clear event log
    document.getElementById('event-log').innerHTML = '';
    logEvent("Started new game with $1,000,000", "success");
    
    // Reset and initialize trading bot if it exists
    if (window.tradingBot) {
        window.tradingBot.stopTrading();
    }
    window.tradingBot = new TradingBot();
    
    // Make sure the bot starts with the correct bankroll
    window.tradingBot.initialBankroll = 1000000;
    
    // Create bot controls and update bot display
    createBotControls();
    updateStrategyDisplay();
    
    // Other initialization
    hideGameOver();
    switchPage('game');
    
    // Start tracking days
    gameState.dayInterval = setInterval(trackDays, 1000);
    
    // Start game timer display
    startGameTimerDisplay();
    
    // Save initial state
    saveGameState();
    
    return gameState;
}



// Update the keyboard handler with error protection
function handleKeyboardNavigation(event) {
    try {
        const key = event.key;
        const dropdown = document.getElementById('product-dropdown');
        const quantityInput = document.getElementById('quantity');


        switch (key) {
            case 'ArrowUp':
            case 'ArrowDown':
                if (document.activeElement === dropdown) {
                    event.preventDefault();
                    const direction = key === 'ArrowUp' ? -1 : 1;
                    dropdown.selectedIndex = Math.max(0, Math.min(dropdown.options.length - 1, 
                        dropdown.selectedIndex + direction));
                    dropdown.dispatchEvent(new Event('change'));
                }
                break;
                
            case 'ArrowLeft':
            case 'ArrowRight':
                event.preventDefault();
                const direction = key === 'ArrowLeft' ? -1 : 1;
                currentElementIndex = (currentElementIndex + direction + focusableElements.length) % focusableElements.length;
                currentFocus = focusableElements[currentElementIndex];
                focusElement(currentFocus);
                break;
                
            case 'Enter':
                event.preventDefault();
                const activeElement = document.activeElement;
                if (activeElement === dropdown || activeElement === quantityInput) {
                    return; // Allow normal form element behavior
                }
                const button = document.getElementById(currentFocus + '-button');
                if (button) {
                    button.click();
                } else {
                    console.warn('No button found for focus:', currentFocus);
                }
                break;
        }
    } catch (error) {
        console.error('Keyboard navigation error:', error);
    }
}

// Update focusElement with null check
function focusElement(elementId) {
    const element = document.getElementById(
        elementId === 'product-dropdown' ? 'product-dropdown' :
        elementId === 'quantity' ? 'quantity' :
        elementId + '-button'
    );
    
    if (element) {
        element.focus();
    } else {
        console.warn('Failed to focus:', elementId);
    }
}

// Update initialization with safety checks
window.onload = function () {
    // Load bot knowledge first
    const savedBotState = localStorage.getItem('botKnowledge');
    if(savedBotState) {
        tradingBot = new TradingBot(JSON.parse(savedBotState));
    } else {
        tradingBot = new TradingBot(); // Fresh bot
    }
    
    // Then load game state
    loadGameState();
    createBotControls();
    initProductDropdown();
    updateUI();
    trackDays();
    
};

// Update enableHumanControls to ensure proper state
function enableHumanControls(enable) {
    // This function is removed as per the instructions
}

function formatTime(totalSeconds) {
    const days = Math.floor(totalSeconds / 86400);
    const hours = Math.floor((totalSeconds % 86400) / 3600);
    return `${days}D ${hours.toString().padStart(2, '0')}H`; // Shows "30D 00H" to "00D 00H"
}

// Keep the timing changes from previous implementation


// Add ASCII art definitions before showAsciiArt function
const currencyAsciiArt = [
    `
''''''=======================================================================|
'''========================================================================||
''======================================================================|||||
||//$\\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\//$\\|||||
||(100)==================| FEDERAL RESERVE NOTE |==================(100)|||||
||\\$//        ~         '------========--------'                  \\$//|||||
||<< /        /$\              // _=-=  \\                          \ >>|||||
||>>|  12    //L\\            // ///..)) \\         L38036133B   12  |<<|||||
||<<|        \\ //           || (||  > \) ||                         |>>|||||
||>>|         \$/            || (((  - /  ||        One Hundred      |<<|||||
||<<|      L38036133B        *\\  |\_ /  //* series                  |>>|||||
||>>|  12                     *\\/____ \_//*   1989                  |<<|||||
||<<\      Treasurer     ______/ Franklin \______     Secretary  12  />>|||||
||//$\                 ~|UNITED STATES OF AMERICA|~                 /$\\|||||
||(100)===================  ONE HUNDRED DOLLARS ===================(100)||||
||\\$//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\$//|||
||======================================================================|| `,
    // Add more currency ASCII art here in the future
];

// Define the ASCII art images
const carAsciiArt = `
======================= __________________ -----------------------------
                      _/ ||          ||    ~-_
                    ,/   //       /~- |      /  ~-_  ________----------//
  -----------------/-----------------\-------------------____________//
 O--------------  /               ~~^ |                             | ~|
 }======{--------\____________________|_____________________________|  |
 \===== / /~~~\ \ \                   |         ____________________|-~
  \----|  \___/ ||--------------------'----------|  \____/ //
_______\`.______.'________________________________\`._______.'____________
`;

const trainAsciiArt = `
/                                 _.-="_-         _
/                           _.-="   _-          | ||"""""""---._______     __..
/                ___.===""""-.______-,,,,,,,,,,,,\`-''----" """""       """""  __'
/         __.--""     __        ,'                   o \           __        [__|
/    __-""=======.--""  ""--.=================================.--""  ""--.=======:
/   ][D]        : /        \ : |========================|    : /   ++   \ :  [D] :
/   V___________:| |  +++   |: |========================|    :|   ++++   |:   _-"
/    V__________: \ \  +   / :_|=======================/_____: \   ++   / :__-"
/    -----------'  "-____-"  \`-------------------------------'  "-____-"
`;

const planeAsciiArt = `
                       _____
                       \\   \\
                        \\   \`\\
      ___                \\    \\
     |AIR \\               \\    \`\\
     |_____\\               \\      \\
     |______\\               \\      \`\\
     |       \\               \\       \\
     |      __\\__---------------------------------._.\\.
   __|---~~~__o_o_o_o_o_o_o_o_o_o_o_o_o_o_o_o   [][\__\`___
  |___      ~  ================/ ~      )-----------------\`\\___
      ~~~---...______________/        ,/_____________________/
                             /       /
                            /      ,/
                           /      /
                          /     ,/
                         /     /
                       //    ,/
                      //    /
                     //   ,/
                    //___/
`;

function showAsciiArt(artType) {
    const container = document.getElementById('ascii-art-container');
    if (!container) {
        console.error('ASCII Container Missing! Check DOM for #ascii-art-container');
        return;
    }

    console.groupCollapsed(`ASCII Art Display: ${artType}`);
    try {
        console.log('üì¶ Container State:', {
            hidden: container.classList.contains('hidden'),
            children: container.children.length,
            timeoutId: container.timeoutId
        });

        if (container.timeoutId) {
            console.log('‚è≥ Clearing previous timeout');
            clearTimeout(container.timeoutId);
        }

        const artMap = {
            buy: [carAsciiArt, currencyAsciiArt[0], trainAsciiArt],
            sell: [currencyAsciiArt[0], trainAsciiArt],
            travel: [planeAsciiArt]
        };

        const artOptions = artMap[artType] || [carAsciiArt];
        const selectedArt = artOptions[Math.floor(Math.random() * artOptions.length)];

        console.log(' Art options:', artOptions);
        console.log(' Selected art:', selectedArt.slice(0, 50));

        container.innerHTML = `<pre>${selectedArt}</pre>`;
        console.log(' Art injected into container');

        container.classList.remove('hidden');
        console.log(' Container made visible');

        // Increase timeout to 3 seconds so the art is visible long enough
        container.timeoutId = setTimeout(() => {
            container.classList.add('hidden');
            console.log(' Hiding art after timeout (after 3 seconds)');
        }, 3000);
    } catch (error) {
        console.error(' Error showing ASCII art:', error);
    } finally {
        console.groupEnd();
    }
}

// =====================
// Bot Control System
// =====================

// Update the TradingBot class with proper state management
class TradingBot {
    constructor(savedState = null) {
        // Initialize all properties here
        this.frequentFlyerPoints = 0;
        this.FLYER_REWARD_THRESHOLDS = [50, 100, 200];
        this.interestRewardPoints = 0;
        this.lastInterestPayment = 0;
        this.lastActionTimestamp = Date.now(); // Initialize timestamp

        // Initialize learning components properly
        this.rewardHistory = [];
        this.lastState = null;
        this.lastAction = null;
        this.previousBankroll = gameState.cash;
        this.previousInventoryValue = 0;
        
        // Initialize exploration parameters
        this.epsilon = 0.7; // Start with high exploration
        this.explorationRate = 0.7; 
        this.learningRate = 0.1;
        this.discountFactor = 0.95;
        this.epsilonDecay = 0.997;
        this.minEpsilon = 0.05;
        
        // Initialize other bot properties
        this.isTrading = false;
        this.tradingInterval = null;
        this.actionCount = 0;
        this.actionInProgress = false;
        this.sessionStartTime = null;
        this.priceHistory = {};
        this.transactionHistory = [];
        this.currentStrategy = "Initializing...";
        this.actionCounter = 0;
        this.cooldown = 1000; // 1 second cooldown between actions by default
    }
    
    // Add necessary methods that were missing
    
    calculateInventoryValue() {
        let totalValue = 0;
        
        // Use gameState.inventory to calculate total value
        for (const productKey in gameState.inventory) {
            if (gameState.inventory[productKey] > 0 && products[productKey]) {
                // Use currentPrice if available, otherwise use average of min and max price
                const currentPrice = products[productKey].currentPrice || 
                    Math.floor((products[productKey].minPrice + products[productKey].maxPrice) / 2);
                    
                totalValue += gameState.inventory[productKey] * currentPrice;
            }
        }
        
        console.log(`[BOT] Current inventory value: $${totalValue.toLocaleString()}`);
        return totalValue;
    }
    
    analyzeMarket() {
        // Create a market analysis object
        const marketAnalysis = {
            highValueProducts: [],
            lowValueProducts: [],
            volatileProducts: [],
            stableProducts: [],
            averagePrices: {},
            cityProfitability: {},
            isPanicSelling: false,
            isOpportunityBuy: false
        };
        
        // Analyze each product
        for (const productKey in products) {
            const product = products[productKey];
            
            // Skip if price info is incomplete
            if (!product.minPrice || !product.maxPrice) continue;
            
            // Calculate current price or use average
            const currentPrice = product.currentPrice || 
                Math.floor((product.minPrice + product.maxPrice) / 2);
            
            // Store average price
            marketAnalysis.averagePrices[productKey] = currentPrice;
            
            // Calculate price position in range (0-1 scale)
            const priceRange = product.maxPrice - product.minPrice;
            const pricePosition = (currentPrice - product.minPrice) / priceRange;
            
            // Categorize products based on price position
            if (pricePosition > 0.7) {
                marketAnalysis.highValueProducts.push(productKey);
            } else if (pricePosition < 0.3) {
                marketAnalysis.lowValueProducts.push(productKey);
            }
            
            // Analyze price history for volatility if available
            if (this.priceHistory && this.priceHistory[productKey] && this.priceHistory[productKey].length > 3) {
                const priceHistory = this.priceHistory[productKey];
                let volatility = 0;
                
                // Calculate price volatility
                for (let i = 1; i < priceHistory.length; i++) {
                    volatility += Math.abs(priceHistory[i] - priceHistory[i-1]) / priceHistory[i-1];
                }
                
                volatility /= (priceHistory.length - 1);
                
                if (volatility > 0.2) {
                    marketAnalysis.volatileProducts.push(productKey);
                } else {
                    marketAnalysis.stableProducts.push(productKey);
                }
            }
        }
        
        // Analyze city profitability
        for (const city of cities) {
            marketAnalysis.cityProfitability[city] = city === gameState.currentCity ? 0.5 : Math.random();
        }
        
        // Determine market conditions
        marketAnalysis.isPanicSelling = marketAnalysis.highValueProducts.length > 3;
        marketAnalysis.isOpportunityBuy = marketAnalysis.lowValueProducts.length > 3;
        
        console.log("[BOT] Market analysis complete:", 
            `High value products: ${marketAnalysis.highValueProducts.length}`, 
            `Low value products: ${marketAnalysis.lowValueProducts.length}`);
            
        return marketAnalysis;
    }
    
    getCurrentStrategy() {
        return this.currentStrategy || "Analyzing market";
    }
    
    selectActionFromLearning(state) {
        // Simple implementation that returns null to fall back to rule-based decision making
        return null;
    }
    
    // Add missing startTrading method
    startTrading() {
        if (this.isTrading) return;
        this.isTrading = true;
        
        console.log("[BOT] Starting trading bot with initial bankroll of $" + gameState.cash.toLocaleString());
        
        // Reset action counter
        this.actionCount = 0;
        
        // Record starting time for this trading session
        this.sessionStartTime = new Date();
        
        // Clear any existing interval
        if (this.tradingInterval) {
            clearInterval(this.tradingInterval);
            this.tradingInterval = null;
        }
        
        // Start the trading loop with a 2-second interval between actions
        this.tradingInterval = setInterval(() => {
            try {
                // Check if we need to adapt strategy
                this.actionCount++;
                if (this.actionCount % 5 === 0 && typeof this.adaptStrategy === 'function') {
                    this.adaptStrategy();
                }
                
                // Check if game is still active
                if (!gameState.gameActive) {
                    this.stopTrading();
                    return;
                }
                
                // Perform the next action
                this.performAction();
                
                // Update strategy display
                updateStrategyDisplay();
                
            } catch (error) {
                console.error("[BOT ERROR]", error);
            }
        }, 2000); // 2-second cooldown between actions
        
        // Indicate bot is running
        const botStatus = document.getElementById('bot-status');
        if (botStatus) {
            botStatus.textContent = "Bot is running";
        }
        
        const toggleButton = document.getElementById('bot-toggle');
        if (toggleButton) {
            toggleButton.textContent = "Stop Bot";
        }
        
        // Make sure to update strategy display
        updateStrategyDisplay();
        
        return true;
    }
    
    // Add missing stopTrading method
    stopTrading() {
        if (!this.isTrading) return;
        
        // Clear trading interval
        if (this.tradingInterval) {
            clearInterval(this.tradingInterval);
            this.tradingInterval = null;
        }
        
        this.isTrading = false;
        
        // Update UI
        const botStatus = document.getElementById('bot-status');
        if (botStatus) {
            botStatus.textContent = "Bot is stopped";
        }
        
        const toggleButton = document.getElementById('bot-toggle');
        if (toggleButton) {
            toggleButton.textContent = "Start Bot";
        }
        
        console.log("[BOT] Trading bot stopped");
        
        return true;
    }
    
    // Add missing performAction method
    performAction() {
        // Check if we're still in the cooldown period
        if (this.actionInProgress) {
            console.log("[BOT] Action in progress, waiting for cooldown...");
            return;
        }

        this.actionInProgress = true;
        
        // Update bot status to show "thinking"
        const botStatus = document.getElementById('bot-status');
        if (botStatus) {
            botStatus.textContent = "Bot is thinking...";
        }
        
        try {
            // Emergency loan check - do this first if cash is critically low
            if (gameState.cash < 25000 && this.shouldEmergencyLoan()) {
                console.log("[BOT] Emergency situation: taking loan to avoid bankruptcy");
                takeLoan(Math.min(500000, 5000000 - gameState.loan), true);
                
                // Update bot status and release cooldown
                if (botStatus) botStatus.textContent = "Bot is running";
                this.actionInProgress = false;
                return;
            }
            
            // Calculate current inventory value
            const inventoryValue = this.calculateInventoryValue();
            
            // Get market conditions
            const market = this.analyzeMarket();
            
            // Determine next action
            let action;
            
            // Try using reinforcement learning to select action
            action = this.selectActionFromLearning({
                cash: gameState.cash,
                inventoryValue: inventoryValue,
                day: gameState.day,
                market: market
            });
            
            // If learning didn't provide an action, use rule-based decision making
            if (!action) {
                // For now, implement a simple rule-based approach
                // In future versions, this would be enhanced with machine learning
                if (gameState.cash < 50000) {
                    // Low on cash, prioritize selling if we have inventory
                    if (inventoryValue > 0) {
                        action = 'sell';
                    } else {
                        // Take a loan if we have no inventory and low cash
                        if (gameState.loan < 5000000) {
                            action = 'loan';
                        }
                    }
                } else {
                    // Sufficient cash, consider buying or traveling
                    if (inventoryValue > gameState.cash * 0.8) {
                        // Heavy on inventory, prioritize selling
                        action = 'sell';
                    } else {
                        // Prioritize buying
                        action = 'buy';
                    }
                }
            }
            
            // Execute the chosen action
            if (action === 'buy') {
                // Find a good product to buy
                const productToBuy = this.getBestBuyOpportunity();
                if (productToBuy) {
                    console.log(`[BOT] Choosing to buy ${productToBuy}`);
                    this.executeBuy(productToBuy);
                } else {
                    console.log("[BOT] No good buying opportunities found");
                }
            } else if (action === 'sell') {
                // Find a good product to sell
                const productToSell = this.getBestSellOpportunity();
                if (productToSell) {
                    console.log(`[BOT] Choosing to sell ${productToSell}`);
                    this.executeSell(productToSell);
                } else {
                    console.log("[BOT] No good selling opportunities found");
                }
            } else if (action === 'loan') {
                // Take a loan
                const loanAmount = Math.min(500000, 5000000 - gameState.loan);
                console.log(`[BOT] Taking a loan of $${loanAmount.toLocaleString()}`);
                takeLoan(loanAmount, true);
            } else {
                console.log("[BOT] No clear action determined");
            }
            
            // Increment action counter
            this.actionCounter = (this.actionCounter || 0) + 1;
            
            // Update current strategy
            this.currentStrategy = "Basic trading strategy";
            
            // Free up the bot to perform next action after cooldown
            setTimeout(() => {
                if (botStatus) botStatus.textContent = "Bot is running";
                this.actionInProgress = false;
            }, 500);
            
        } catch (error) {
            console.error("[BOT ERROR] Error in performAction:", error);
            // Make sure to release the lock even if there's an error
            this.actionInProgress = false;
            if (botStatus) botStatus.textContent = "Bot is running (recovered from error)";
        }
    }
    
    // Add placeholder methods for other required functions
    shouldEmergencyLoan() {
        // Simple implementation: take a loan if we're below 25k and loan is below limit
        return gameState.cash < 25000 && gameState.loan < 5000000;
    }
    
    getBestBuyOpportunity() {
        // Simple implementation: find a product with price near its minimum
        let bestProduct = null;
        let bestRatio = 1.0;  // Lower is better
        
        for (const productKey in products) {
            const product = products[productKey];
            if (!product.minPrice || !product.maxPrice) continue;
            
            const currentPrice = product.currentPrice || 
                Math.floor((product.minPrice + product.maxPrice) / 2);
                
            const priceRange = product.maxPrice - product.minPrice;
            const priceRatio = (currentPrice - product.minPrice) / priceRange;
            
            if (priceRatio < bestRatio) {
                bestRatio = priceRatio;
                bestProduct = productKey;
            }
        }
        
        return bestProduct;
    }
    
    getBestSellOpportunity() {
        // Simple implementation: find a product with price near its maximum
        let bestProduct = null;
        let bestRatio = 0.0;  // Higher is better
        
        for (const productKey in gameState.inventory) {
            if (!gameState.inventory[productKey] || gameState.inventory[productKey] <= 0) continue;
            
            const product = products[productKey];
            if (!product || !product.minPrice || !product.maxPrice) continue;
            
            const currentPrice = product.currentPrice || 
                Math.floor((product.minPrice + product.maxPrice) / 2);
                
            const priceRange = product.maxPrice - product.minPrice;
            const priceRatio = (currentPrice - product.minPrice) / priceRange;
            
            if (priceRatio > bestRatio) {
                bestRatio = priceRatio;
                bestProduct = productKey;
            }
        }
        
        return bestProduct;
    }
    
    executeBuy(productKey) {
        if (!productKey || !products[productKey]) {
            console.log("[BOT] Invalid product for buying");
            return;
        }
        
        // Select the product
        const selectElement = document.getElementById('product-dropdown');
        if (!selectElement) {
            console.error("[BOT BUY ERROR] Product dropdown not found");
            return;
        }
        
        selectElement.value = productKey;
        
        // Calculate how much we can buy
        const buyPrice = products[productKey].currentPrice || 
            Math.floor((products[productKey].minPrice + products[productKey].maxPrice) / 2);
            
        // Use 90% of cash to leave some reserves
        const maxQuantity = Math.floor((gameState.cash * 0.9) / buyPrice);
        
        if (maxQuantity <= 0) {
            console.log(`[BOT] Not enough cash to buy ${productKey}`);
            return;
        }
        
        // Set quantity
        const quantityInput = document.getElementById('quantity');
        if (!quantityInput) {
            console.error("[BOT BUY ERROR] Quantity input not found");
            return;
        }
        
        quantityInput.value = maxQuantity;
        
        // Execute buy
        buyProduct();
    }
    
    executeSell(productKey) {
        if (!productKey || !gameState.inventory[productKey] || gameState.inventory[productKey] <= 0) {
            console.log(`[BOT] Cannot sell ${productKey}: no inventory available`);
            return;
        }
        
        // Complete the sell operation
        this._completeSell(productKey);
    }
    
    _completeSell(productKey) {
        // More detailed inventory logging for debugging
        console.log(`[BOT DEBUG] Current inventory when selling ${productKey}:`, JSON.stringify(gameState.inventory));
        
        // Standardize product key for case-insensitive comparison
        const normalizedProductKey = productKey.toLowerCase();
        
        // Handle potential key format variations and empty inventory
        if (!gameState.inventory) {
            console.error("[BOT SELL ERROR] Game state inventory is not initialized");
            return;
        }

        // Check inventory in a more robust way
        let inventoryAvailable = false;
        let actualProductKey = productKey;
        
        // Look for the product in inventory with different case possibilities
        for (const key in gameState.inventory) {
            if (key.toLowerCase() === normalizedProductKey && gameState.inventory[key] > 0) {
                inventoryAvailable = true;
                actualProductKey = key; // Use the actual key case that exists in inventory
                break;
            }
        }
        
        if (!inventoryAvailable) {
            console.log(`[BOT] Cannot sell ${productKey}: no inventory available. Current inventory: ${JSON.stringify(gameState.inventory)}`);
            return;
        }
        
        // Log the found inventory
        console.log(`[BOT] Found ${gameState.inventory[actualProductKey]} ${products[actualProductKey].name} in inventory`);

        try {
            // Get current product selection and set it to the product we want to sell
            const selectElement = document.getElementById('product-dropdown');
            if (!selectElement) {
                console.error("[BOT SELL ERROR] Product dropdown not found");
                return;
            }

            // Set the product dropdown to our selected product
            selectElement.value = actualProductKey;
            
            // Trigger change event to update UI prices
            const changeEvent = new Event('change');
            selectElement.dispatchEvent(changeEvent);
            
            // Important: Wait for the UI to update after changing the product
            setTimeout(() => {
                // Now get the quantity and set it
                const quantityInput = document.getElementById('quantity');
                if (!quantityInput) {
                    console.error("[BOT SELL ERROR] Quantity input not found");
                    return;
                }
                
                // Determine quantity to sell (all of it)
                const inventory = gameState.inventory[actualProductKey] || 0;
                const quantityToSell = inventory;
                
                // Set the quantity input
                quantityInput.value = quantityToSell;
                
                // Execute sell through the sellProduct function
                if (sellProduct()) {
                    console.log(`[BOT] Successfully sold ${quantityToSell} ${products[actualProductKey].name}`);
                } else {
                    console.error(`[BOT SELL ERROR] Failed to sell ${products[actualProductKey].name}`);
                }
                
            }, 150); // 150ms delay to allow UI to update after product selection
        } catch (error) {
            console.error("[BOT SELL ERROR]", error);
        }
    }
    
    // Add the adaptStrategy method
    adaptStrategy() {
        // Track rewards received over time
        if (!this.rewardHistory) {
            this.rewardHistory = [];
        }
        
        // Calculate recent average reward
        const recentRewards = this.rewardHistory.slice(-10); // Last 10 rewards
        const avgReward = recentRewards.length > 0 
            ? recentRewards.reduce((sum, r) => sum + r, 0) / recentRewards.length 
            : 0;
            
        console.log(`[BOT] Average recent reward: ${avgReward.toFixed(2)}`);
        
        // Adjust exploration rate based on performance
        if (avgReward < 0) {
            // If we're doing poorly, increase exploration to find new strategies
            this.epsilon = Math.min(0.8, this.epsilon * 1.1);
            console.log(`[BOT] Increasing exploration to ${this.epsilon.toFixed(2)} due to poor performance`);
        } else if (avgReward > 10) {
            // If we're doing well, slightly reduce exploration to exploit current strategy
            this.epsilon = Math.max(0.05, this.epsilon * 0.95);
            console.log(`[BOT] Decreasing exploration to ${this.epsilon.toFixed(2)} to exploit successful strategy`);
        }
        
        // Every 15 actions, reconsider if we should travel
        if (this.actionCounter % 15 === 0) {
            console.log('[BOT] Reconsidering travel strategy');
            // Check if we should travel - implement this logic
        }
    }
    
    // Rest of the TradingBot class...
}

// Function to update the strategy display for the bot
function updateStrategyDisplay() {
    try {
        // First check if bot controls exist - if not, there's nothing to update yet
        const botControls = document.getElementById('bot-controls');
        if (!botControls) {
            // Bot controls don't exist yet, so exit silently without warnings
            return;
        }
        
        // Now check for strategy container
        const strategyContainer = document.getElementById('strategy-display');
        if (!strategyContainer) {
            // Only create the strategy display if bot controls exist but strategy display doesn't
            console.log('Creating strategy display container');
            
            const newStrategyDisplay = document.createElement('div');
            newStrategyDisplay.id = 'strategy-display';
            
            const strategyLabel = document.createElement('span');
            strategyLabel.className = 'strategy-label';
            strategyLabel.textContent = 'Strategy: ';
            
            const currentStrategy = document.createElement('span');
            currentStrategy.id = 'current-strategy';
            currentStrategy.textContent = 'Initializing...';
            
            newStrategyDisplay.appendChild(strategyLabel);
            newStrategyDisplay.appendChild(currentStrategy);
            botControls.appendChild(newStrategyDisplay);
            
            // Now use this new container
            return updateStrategyDisplay();
        }
        
        // Find or create the current-strategy element
        let currentStrategyElement = document.getElementById('current-strategy');
        if (!currentStrategyElement) {
            currentStrategyElement = document.createElement('span');
            currentStrategyElement.id = 'current-strategy';
            strategyContainer.appendChild(currentStrategyElement);
        }
        
        if (!tradingBot) {
            currentStrategyElement.textContent = "Bot inactive";
            return;
        }
        
        // Get current bot strategy
        const strategy = tradingBot.getCurrentStrategy?.() || "Analyzing market";
        
        // Update strategy display
        currentStrategyElement.textContent = strategy;
        
        // Log metrics to console instead of displaying in UI
        if (tradingBot) {
            console.log(`[BOT METRICS] Trades: ${tradingBot.actionCounter || 0}, Travel Points: ${tradingBot.frequentFlyerPoints || 0}`);
        }
    } catch (error) {
        console.error('[STRATEGY DISPLAY ERROR]', error);
    }
}

// Function to create bot controls in the UI
function createBotControls() {
    try {
        // Check if controls already exist
        if (document.getElementById('bot-controls')) {
            return; // Controls already exist
        }
        
        // Find the game container and its parent
        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) {
            console.warn('Game container not found');
            return;
        }
        
        const parentElement = gameContainer.parentElement;
        
        // Create bot controls container
        const botControlsContainer = document.createElement('div');
        botControlsContainer.id = 'bot-controls';
        botControlsContainer.className = 'bot-controls';
        
        // Create toggle button
        const toggleButton = document.createElement('button');
        toggleButton.id = 'bot-toggle';
        toggleButton.textContent = botEnabled ? 'Disable AI' : 'Enable AI';
        toggleButton.className = botEnabled ? 'bot-enabled' : 'bot-disabled';
        toggleButton.onclick = toggleAI;
        
        // Create strategy display container
        const strategyDisplay = document.createElement('div');
        strategyDisplay.id = 'strategy-display';
        
        // Create strategy label and current strategy elements
        const strategyLabel = document.createElement('span');
        strategyLabel.className = 'strategy-label';
        strategyLabel.textContent = 'Strategy: ';
        
        const currentStrategy = document.createElement('span');
        currentStrategy.id = 'current-strategy';
        currentStrategy.textContent = 'Initializing...';
        
        // Add elements to container
        strategyDisplay.appendChild(strategyLabel);
        strategyDisplay.appendChild(currentStrategy);
        
        botControlsContainer.appendChild(toggleButton);
        botControlsContainer.appendChild(strategyDisplay);
        
        // Insert before game container
        parentElement.insertBefore(botControlsContainer, gameContainer);
        
        // Log initial bot state to console
        console.log('[BOT] Controls positioned above game container');
        if (tradingBot) {
            console.log('[BOT INITIAL METRICS]', {
                trades: tradingBot.actionCounter || 0,
                travelPoints: tradingBot.frequentFlyerPoints || 0
            });
        }
        
        // Update strategy display
        updateStrategyDisplay();
    } catch (error) {
        console.error('[CREATE BOT CONTROLS ERROR]', error);
    }
}

// Function to toggle AI
function toggleAI() {
    botEnabled = !botEnabled;
    
    const toggleButton = document.getElementById('bot-toggle');
    if (toggleButton) {
        toggleButton.textContent = botEnabled ? 'Disable AI' : 'Enable AI';
        toggleButton.className = botEnabled ? 'bot-enabled' : 'bot-disabled';
    }
    
    if (botEnabled) {
        if (tradingBot) {
            tradingBot.startTrading();
        } else {
            tradingBot = new TradingBot();
        }
        logEvent("AI trader activated");
    } else {
        if (tradingBot) {
            tradingBot.stopTrading();
        }
        logEvent("AI trader deactivated");
    }
    
    updateStrategyDisplay();
}

// Add this function near the other player action functions
function handlePlayerAction() {
    // Increment transaction count
    transactionCount++;
    
    // Check for random events based on transaction count
    if (transactionCount % 5 === 0 && Math.random() < 0.3) {
        randomEvent();
    }
    
    // Update prices occasionally (25% chance)
    if (Math.random() < 0.25) {
        updatePrices();
    }
    
    // Save game state
    saveGameState();
}

// Add this new function after formatTime() function
function startGameTimerDisplay() {
    // Clear any existing timer
    if (window.gameTimerInterval) {
        clearInterval(window.gameTimerInterval);
    }
    
    // Update the timer display every 100ms for smooth updates
    window.gameTimerInterval = setInterval(() => {
        const timeDisplay = document.getElementById('time-display');
        if (timeDisplay && typeof gameTime !== 'undefined') {
            timeDisplay.textContent = formatTime(gameTime);
        }
    }, 100);
}

// Modify the startNewGame function to start the timer display
function startNewGame() {
    // ... existing code ...
    
    // Initialize game variables
    currentCity = cities[0];
    gameTime = 60 * 60 * 24 * 30; // Start with 30 days
    bankroll = 2000;
    inventory = {};
    Object.keys(products).forEach(product => {
        inventory[product] = 0;
    });
    loan = 0;
    deposited = 0;
    currentProduct = 'Weed';
    gunOwned = false;
    dayInterval = null;
    randomEventsDisabled = false;
    loggedEvents = [];
    
    // Start the continuous timer display
    startGameTimerDisplay();
    
    // ... rest of existing code ...
}

// Modify the loadGameState function to restart the timer display when loading a game
function loadGameState() {
    // ... existing code ...
    
    updateUI();
    
    // Start the continuous timer display for the loaded game
    startGameTimerDisplay();
    
    // ... rest of existing code ...
}

// Add cleanup for the timer in the gameOver function or anywhere the game ends
function hideGameOver() {
    document.getElementById('game-over').classList.add('hidden');
    document.getElementById('game-container').classList.remove('hidden');
    
    // Clear the game timer interval when game is over
    if (window.gameTimerInterval) {
        clearInterval(window.gameTimerInterval);
        window.gameTimerInterval = null;
    }
}

// Add this function after hideGameOver to properly show the game over screen
function showGameOver() {
    // Calculate total net worth including inventory
    const inventoryValue = calculateTotalInventoryValue();
    const netWorth = bankroll + inventoryValue + bankBalance - loanBalance;
    
    // Get the game over container
    const gameOverElement = document.getElementById('game-over');
    if (!gameOverElement) {
        console.error("Game over element not found");
            return;
        }
        
    // Update game over content with final stats
    let gameOverContent = `
        <h2>GAME OVER</h2>
        <div class="final-stats">
            <p>Final Bankroll: $${bankroll.toLocaleString()}</p>
            <p>Inventory Value: $${inventoryValue.toLocaleString()}</p>
            <p>Bank Balance: $${bankBalance.toLocaleString()}</p>
            <p>Outstanding Loans: $${loanBalance.toLocaleString()}</p>
            <hr>
            <p class="total-worth">TOTAL NET WORTH: $${netWorth.toLocaleString()}</p>
        </div>
        <button id="restart-game" onclick="startNewGame()">Start New Game</button>
    `;
    
    // Update the game over element
    gameOverElement.innerHTML = gameOverContent;
    
    // Show game over screen, hide game container
    gameOverElement.classList.remove('hidden');
    document.getElementById('game-container').classList.add('hidden');
    
    // Stop the trading bot if active
    if (tradingBot) {
        tradingBot.stopTrading();
    }
    
    // Clear the game timer interval
    if (window.gameTimerInterval) {
        clearInterval(window.gameTimerInterval);
        window.gameTimerInterval = null;
    }
    
    // Stop the day tracking interval
    if (gameInterval) {
        clearInterval(gameInterval);
        gameInterval = null;
    }
    
    console.log("[GAME OVER] Final net worth: $" + netWorth.toLocaleString());
}

// Add helper function to calculate total inventory value
function calculateTotalInventoryValue() {
    let totalValue = 0;
    
    // Debug inventory status
    console.log("[INVENTORY DEBUG] Current gameState.inventory:", JSON.stringify(gameState.inventory));
    
    // Use gameState.inventory instead of the global inventory variable
    for (const [productKey, quantity] of Object.entries(gameState.inventory)) {
        if (quantity > 0 && products[productKey]) {
            // Use currentPrice if available, otherwise use average of min and max price
            const currentPrice = products[productKey].currentPrice || 
                Math.floor((products[productKey].minPrice + products[productKey].maxPrice) / 2);
            totalValue += quantity * currentPrice;
            
            // Debug each product calculation
            console.log(`[INVENTORY VALUE] ${quantity} ${productKey} at $${currentPrice} = $${(quantity * currentPrice).toLocaleString()}`);
        }
    }
    
    console.log(`[INVENTORY] Total value: $${totalValue.toLocaleString()}`);
    return totalValue;
}
